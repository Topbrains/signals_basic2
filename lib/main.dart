import 'package:flutter/material.dart';
import 'package:signals/signals_flutter.dart';

void main() {
  runApp(const App());
}

class App extends StatelessWidget {
  const App({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Signals Effect',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: const HomePage(title: 'Signals: Use of effect'),
    );
  }
}

class HomePage extends StatefulWidget {
  const HomePage({super.key, required this.title});
  final String title;

  @override
  State<HomePage> createState() => _HomePageState();
}

class _HomePageState extends State<HomePage> {
  final _counter = signal(0);

  void _incrementCounter() {
    // Schau, Mutter, nicht ein setState(() {});
    _counter.value++;
  }

  final List<int> list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
  // To toggle Play Stop buttons
  bool isEffect = true;

  // To display the sorted list
  final myListSignal = listSignal(<int>[]);

  // To hold the pointer to the stop signal for the effect
  void Function() disposeEffect = effect(() {});

  @override
  Widget build(BuildContext context) {
    debugPrint('======> HomePage build <=======');

    final isCounterEven = computed(() => _counter.value.isEven);

    return Scaffold(
      appBar: AppBar(
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        title: Text(widget.title),
      ),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(32.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Text(
                'Showing the use of effect to display a sorted list and how we can start and stop the effect function. Notice that this HomePage widget is a StatefulWidget and therefore we can use setState().\n\nAlso watch the times that the build function of this HomePage is called in the debug console. You will see that the only builds are triggered because of the setState() calls when flipping the run and stop buttons.',
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32.0),
              const Text('Original List:'),
              Text(list.toString()),
              const SizedBox(height: 32.0),
              const Text(
                'You have pushed the button this many times:',
              ),
              Watch((context) {
                return Column(
                  children: [
                    Text('${_counter.value}',
                        style: TextStyle(
                            color:
                                isCounterEven.value ? Colors.blue : Colors.red,
                            fontSize: 25)),
                    const SizedBox(height: 32.0),
                    const Text('Generated by the effect function:'),
                    Text(myListSignal.peek().toString(),
                        style: TextStyle(
                            color:
                                isCounterEven.value ? Colors.blue : Colors.red,
                            fontSize: 25))
                  ],
                );
              }),
            ],
          ),
        ),
      ),
      floatingActionButton: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // Increment
          FloatingActionButton(
            onPressed: _incrementCounter,
            tooltip: 'Increment Counter and Sort',
            child: const Icon(Icons.add),
          ),
          const SizedBox(width: 32.0),
          // Start effect
          Visibility(
            visible: isEffect,
            child: FloatingActionButton(
              // backgroundColor: isEffect ? Colors.grey : Colors.blue,
              onPressed: () {
                // Warning: With effects if you call them twice while they are running you will
                // get a recursion error. Recursion errors are very common while developing reactive
                // applications. Our effect is store in the disposeEffect pointer so that we can cancel
                // it, if we call it again we can get into recursion issues. This is why I first clear it
                // and then create it:

                debugPrint('=======> Start Effect Clicked <=========');
                setState(() {
                  isEffect = !isEffect;
                });
                disposeEffect = effect(() {
                  myListSignal.value =
                      (_counter.value.isEven ? [...list] : [...list].reversed)
                          .toList();
                  // Every time intListSignal changes, this SnackBar will show
                  if (context.mounted) {
                    // Remove any existing snackbar
                    ScaffoldMessenger.of(context).removeCurrentSnackBar();
                    // Show SnackBar
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        // peek() allows us to access the value of the signal without triggering
                        // reactive updates of dependencies
                        content: Text(
                          'Effect: ${myListSignal.peek()} ',
                        ),
                        duration: const Duration(milliseconds: 100),
                      ),
                    );
                  }
                });
              },
              tooltip: 'Start Effect',
              child: const Icon(Icons.play_arrow),
            ),
          ),
          const SizedBox(width: 32.0),
          // Stop effect
          Visibility(
            visible: !isEffect,
            child: FloatingActionButton(
              // backgroundColor: isEffect ? Colors.blue : Colors.grey,
              onPressed: () {
                debugPrint('=======> Stop Effect Clicked <=========');
                myListSignal.value = [];
                setState(() {
                  isEffect = !isEffect;
                });
                disposeEffect();
                // Cancel previous if any
                ScaffoldMessenger.of(context).removeCurrentSnackBar();
                // Show message indicating cancelled
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text(
                      'Effect Cancelled',
                    ),
                      duration: Duration(milliseconds: 500),
                  ),
                );
              },
              tooltip: 'Stop Effect',
              child: const Icon(Icons.stop),
            ),
          ),
        ],
      ),
    );
  }
}
